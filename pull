#!/bin/rc -e

rfork en

nl='
'

fn update{
	branch=$1
	url=$2
	dir=$3
	
	{git/fetch -b $1 $2 >[2=3] | awk '
		/^remote/{
			if($2=="HEAD")
				next

			gsub("^refs/heads", "refs/remotes/'$remote'", $2)
			outfile = ".git/" $2
			system("mkdir -p `{basename -d "outfile"}")
			print $3 > outfile
			close(outfile)
		}
	'} |[3] tr '\x0d' '\x0a'
}

fn usage{
	echo 'usage: $argv0 [-a] [-u upstream] [-b branch]' >[1=2]
	echo '	-u up:	pull from upstream "up" (default: origin)' >[1=2]
	echo '	-f:	fetch without updating working copy' >[1=2]
	exit usage
}

git/fs
branch=`{awk '$1=="branch"{print $2}' < /mnt/git/ctl}
upstream=origin
while(~ $1 -*){
	switch($1){
	case -u;
		shift
		upstream=$1
	case -b:
		shift
		branch=$1
	case -f;
		fetch=true
	case *;
		usage
	}
	shift
}

if(! ~ $#* 0)
	usage
if(! ~ $#remote 0)
	remote=`{git/conf 'remote "'$upstream'".url'}
if(~ $#remote 0)
	remote=$upstream
if(~ $#remote 0){
	echo 'no idea from where to pull'
	exit upstream
}

if(! cd `{git/conf -r})
	exit 'not in git repository'

dir=/mnt/git/branch/$branch/tree
if(! git/walk -q){
	echo $status
	echo 'repository is dirty: commit before pulling' >[1=2]
	exit 'dirty'
}
oldfiles=`$nl{git/walk -cfT}
update $branch $remote $dir
if(~ $fetch ''){
	rm -f $oldfiles
	tree=/mnt/git/HEAD/tree
	@{builtin cd $tree && tar cif /fd/1 .} | @{tar xf /fd/0}
	for(f in `$nl{walk -f $tree | sed 's@^'$tree'/*@@'}){
		if(! ~ $#f 0){
			idx=.git/index9/tracked/$f
			mkdir -p `{basename -d $idx}
			walk -eq $f > $idx
		}
	}
}
